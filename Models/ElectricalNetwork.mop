package ElectricNetwork
	"This package contains simple models for optimization problems with electrical networks"
	
	model Derivative
    	input Real u "input";
    	output Real y "derivative";
    	parameter Real T = 0.1 "time constant";
    	parameter Real k = 1 "gain";
   	protected
    	Real x (start = 0, fixed=true);
   	equation
   		y = k/T*(u - x);
   		der(x) = (u - x)/T;
   	end Derivative;
   	
   	model FirstOrder
    	input Real u "input";
    	output Real y "derivative";
    	parameter Real T = 0.1 "time constant";
    	parameter Real k = 1 "gain";
   	protected
    	Real x (start = 0, fixed=true);
   	equation
   		x + T*der(x) = k*u;
   		y = x;
   	end derivative;

	function smooth_max
		input Real a;
		input Real b;
		output Real y;
	protected 
		Real x;
		Real alpha;
		parameter Real delta = 0.1;
	algorithm 
		x := (a - b)/delta;
		alpha := (atan(x)/asin(1) + 1)/2;
		y := alpha*a + (1-alpha)*b;
		annotation(smoothOrder = 2,
		derivative = der_smooth_max);
	end smooth_max;
	
	function der_smooth_max
		input Real a;
		input Real b;
		input Real der_a;
		input Real der_b;
		output Real out;
	protected
		parameter Real delta = 0.1;
		Real alpha;
		Real x;
	algorithm
		x := (a - b)/delta;
		alpha := (atan(x)/asin(1) + 1)/2;
		out := alpha*der_a - alpha*der_b;
		annotation(smoothOrder = 1,
		derivative(order = 2) = der_der_smooth_max);
	end der_smooth_max;

	function der_der_smooth_max
		input Real a;
		input Real b;
		input Real der_a;
		input Real der_b;
		input Real der_2_a;
		input Real der_2_b;
		output Real out;
	protected
		parameter Real delta = 0.1;
		Real alpha;
		Real der_alpha;
		Real x;
	algorithm
		x := (a - b)/delta;
		alpha := (atan(x)/asin(1) + 1)/2;
		der_alpha := 1/asin(1)/(x^2 + 1);
		out := der_alpha*der_a + alpha*der_2_a - (der_alpha*der_b + alpha*der_2_b);
		annotation(smoothOrder = 0);
	end der_der_smooth_max;

	function smooth_min
		input Real a;
		input Real b;
		output Real y;
	protected 
		Real x;
		Real alpha;
		parameter Real delta = 0.1;
	algorithm 
		x := (a - b)/delta;
		alpha := (atan(x)/asin(1) + 1)/2;
		y := alpha*b + (1-alpha)*a;
		annotation(smoothOrder = 2,
		derivative = der_smooth_min);
	end smooth_min;

	function der_smooth_min
		input Real a;
		input Real b;
		input Real der_a;
		input Real der_b;
		output Real out;
	protected
		parameter Real delta = 0.1;
		Real alpha;
		Real x;
	algorithm
		x := (a - b)/delta;
		alpha := (atan(x)/asin(1) + 1)/2;
		out := alpha*der_b - alpha*der_a;
		annotation(smoothOrder = 1,
		derivative(order = 2) = der_der_smooth_min);
	end der_smooth_min;

	function der_der_smooth_min
		input Real a;
		input Real b;
		input Real der_a;
		input Real der_b;
		input Real der_2_a;
		input Real der_2_b;
		output Real out;
	protected
		parameter Real delta = 0.1;
		Real alpha;
		Real der_alpha;
		Real x;
	algorithm
		x := (a - b)/delta;
		alpha := (atan(x)/asin(1) + 1)/2;
		der_alpha := 1/asin(1)/(x^2 + 1);
		out := der_alpha*der_b + alpha*der_2_b - (der_alpha*der_a + alpha*der_2_a);
		annotation(smoothOrder = 0);
	end der_der_smooth_min;

	function smooth_lim
		input Real u;
		input Real M;
		input Real m;
		output Real y;
	algorithm 
		y := ElectricNetwork.smooth_max(m, ElectricNetwork.smooth_min(M, u));
	end smooth_lim;

	model smooth_lim_PI
		Modelica.Blocks.Interfaces.RealInput sp;
		Modelica.Blocks.Interfaces.RealInput pv;
		Modelica.Blocks.Interfaces.RealOutput cs;
		parameter Real K = 1;
		parameter Real Ti = 10;
		parameter Real b = 1.0;
		parameter Real CS_start = 0;
		parameter Real CS_max = 1;
		parameter Real CS_min = 0;
	protected 
		Real f_cs;
	initial equation
		f_cs = CS_start - K*(b*sp - pv);
	equation 
		cs = ElectricNetwork.smooth_lim(K*(b*sp - pv) + f_cs, CS_max, CS_min);
		//cs = max(CS_min, min(K*(b*sp - pv) + f_cs, CS_max));
		//cs = K*(b*sp - pv) + f_cs;
		f_cs + Ti*der(f_cs) = cs;
	end smooth_lim_PI;
	
	connector Pin
		Modelica.SIunits.Voltage v[2];
		flow Modelica.SIunits.Current i[2];
	end Pin;
	
	model Source
		ElectricNetwork.Pin p;
		parameter Modelica.SIunits.Voltage Vrms = 4800;
		parameter Modelica.SIunits.Angle theta = 0;
	equation
		p.v[1] = Vrms*cos(theta);
		p.v[2] = Vrms*sin(theta);
	end Source;
	
	model Line
		ElectricNetwork.Pin a;
		ElectricNetwork.Pin b;
		parameter Modelica.SIunits.Resistance R = 0.1;
		parameter Modelica.SIunits.Resistance X = 0;
	equation
		a.i[1] + b.i[1] = 0;
		a.i[2] + b.i[2] = 0;
		a.v[1] - b.v[1] = a.i[1]*R - a.i[2]*X;
		a.v[2] - b.v[2] = a.i[2]*R + a.i[1]*X;
	end Line;
	
	model Load
		ElectricNetwork.Pin p(v(start = {Vn, 0}));
		Modelica.SIunits.Voltage Vrms(start = Vn);
		parameter Modelica.SIunits.Voltage Vn = 220;
		Modelica.Blocks.Interfaces.RealInput P;
		Modelica.Blocks.Interfaces.RealInput Q;
	equation
		Vrms = sqrt(p.v[2]^2 + p.v[1]^2);
		//p.i[1] = -(p.v[2]*Q + p.v[1]*P)/(Vn^2);
	    //p.i[2] = -(p.v[2]*P - p.v[1]*Q)/(Vn^2);
	    p.i[1] = -(p.v[2]*Q + p.v[1]*P)/(p.v[1]^2 + p.v[2]^2);
	    p.i[2] = -(p.v[2]*P - p.v[1]*Q)/(p.v[1]^2 + p.v[2]^2);
	end Load;
	
	model Battery
		extends ElectricNetwork.Load;
		parameter Modelica.SIunits.Energy Ebatt = 100 "Storage capacity for the battery";
		parameter Real SOCstart = 0.5;
		Real SOC(start = SOCstart, fixed = true, min = 0, max = 1);
	equation
		// Ideal battery model
		Ebatt*der(SOC) = -P;
	end Battery;
	
	block StateSpace "Linear state space system"
	  parameter Real A[:, size(A, 1)]=[1, 0; 0, 1] 
	    "Matrix A of state space model (e.g., A=[1, 0; 0, 1])";
	  parameter Real B[size(A, 1), :]=[1; 1] 
	    "Matrix B of state space model (e.g., B=[1; 1])";
	  parameter Real C[:, size(A, 1)]=[1, 1] 
	    "Matrix C of state space model (e.g., C=[1, 1])";
	  parameter Real D[size(C, 1), size(B, 2)]=zeros(size(C, 1), size(B, 2)) 
	    "Matrix D of state space model";
	  parameter Real x_start[nx]=zeros(nx) "Initial or guess values of states";
	  parameter Integer nin=size(B, 2) "Number of inputs";
  	  parameter Integer nout=size(C, 1) "Number of outputs";
      Modelica.Blocks.Interfaces.RealInput u[nin] "Connector of Real input signals";
      Modelica.Blocks.Interfaces.RealOutput y[nout] "Connector of Real output signals";
	  output Real x[size(A, 1)](start=x_start) "State vector";
	protected 
	  parameter Integer nx = size(A, 1) "number of states";
	  parameter Integer ny = size(C, 1) "number of outputs";
	initial equation 
	  x = x_start;
	equation 
	  der(x) = A*x + B*u;
	  y = C*x + D*u;
	end StateSpace;

	partial model BaseBuilding
	  "Base class for a linearized model described by A,B matrices"
	  //
	  //  u[1] v_IG_Offices [W/m2]
	  //  u[2] v_Tamb
	  //  u[3] v_Tgnd
	  //  u[4] v_solGlobFac_E [W/m2]
	  //  u[5] v_solGlobFac_N [W/m2]
	  //  u[6] v_solGlobFac_S [W/m2]
	  //  u[7] v_solGlobFac_W [W/m2]
	  //
	  Modelica.Blocks.Interfaces.RealInput P_hvac "Cooling/Heating power supplied by the HVAC system";
	  Modelica.Blocks.Interfaces.RealInput P_batt "Power used to charge and discharge the battery";
	  Modelica.Blocks.Interfaces.RealOutput P_el "Electric power consumed by the HVAC system";
	  Modelica.Blocks.Interfaces.RealOutput E(start = 0.0, fixed = true) "Energy consumed by the HVAC in kWh";
	  Modelica.Blocks.Interfaces.RealInput price "Price of kWh";
	  
	  parameter Modelica.SIunits.Area A_tot "Area of the building";
      parameter Real ihg_el_ratio = 0.5 "Fraction of ihg power that is also electrical";
	  Real COP "Nominal Coefficient of performance of the HVAC system";
      Real Money(start = 0.0, fixed = true) "Money spent";
      Real Pctrl "power from control system";
      
      // Thermal model of the building
	  parameter Modelica.SIunits.Temperature Tstart "Initial temperatures of all the elements";
	  parameter Integer N "Number of state variables";
	  parameter Integer M "Number of inputs";
	  parameter Integer O = N + 1 "Number of outputs";
	  Modelica.Blocks.Interfaces.RealInput u[M] "External inputs";
	  Modelica.Blocks.Interfaces.RealOutput x[O](each unit="K") "State variables";
	  ElectricNetwork.StateSpace
	    linBuiModel(
	    A=A,
	    B=B,
	    C=C,
	    x_start=Tstart*ones(size(A, 1))) "Linear model of a building";
	  Modelica.Blocks.Interfaces.RealOutput Tmix(unit="K") "Averaged temperature of the air in the building";
	    
	  // Electric models
	  ElectricNetwork.Battery batt(Vn=Vs, SOCstart=SOCstart, Ebatt=Ebatt);
	  ElectricNetwork.Load bldg(Vn=Vs);
	  parameter Modelica.SIunits.Power P_nominal = 200000 "Nominal power of the building";
	  parameter Modelica.SIunits.Voltage Vs = 4800 "Voltage source";
	  parameter Real cosPhi = 0.9 "Power factor of the building load";
	  parameter Modelica.SIunits.Energy Ebatt = (P_nominal)*3*3600 "Battery storage capacity";
      parameter Real SOCstart = 0.5;
      ElectricNetwork.Pin p "Electric port for of the building";        
	protected
	  Real P_m2 "Power by HVAC per square meter";
	  parameter Real A[N,N] = zeros(N,N) "State matrix A";
	  parameter Real B[N,M] = zeros(N,M) "Input matrix B";
	  parameter Real C[O,N] = [diagonal(ones(N)); zeros(1,N)] "Output state matrix C";
	equation
	  // Computation of the electric power and energy
      COP = 3+285.0*1.0/28.0 - 1.0/28.0*u[2];
	  P_el = u[1]*ihg_el_ratio*A_tot + (P_hvac+Pctrl)*atan(P_hvac+Pctrl)/asin(1)/COP;
	  P_m2 = (P_hvac+Pctrl)/A_tot;
 
	  // Connect the inputs to building model
	  linBuiModel.u[1] = u[1] + P_m2;
	  connect(linBuiModel.u[2:7], u[2:7]);
	
	  // Connects the states (in this case also outputs variables)
	  connect(linBuiModel.y[1:O], x[1:O]);
	
	  // Connect the last of the outputs (averaged Tmix)
	  connect(linBuiModel.y[O], Tmix);
	  
	  // Connect loads and battery to electric connector
	  connect(p, bldg.p);
	  connect(p, batt.p);
	  
	  // Associate powers to the electric loads and battery
	  batt.P = P_batt;
	  batt.Q = 0.0;
	  
	  bldg.P = -P_el;
	  bldg.Q = -P_el*tan(acos(cosPhi));
	  
	end BaseBuilding;

	partial model BaseBuildingPV
	  extends BaseBuilding;
	  
	  // Electric models
	  ElectricNetwork.Load pv(Vn=Vs);
	  parameter Real A_s = 0.9 "Ratio of PV oriented towards south";
	  parameter Real A_n = 0.0 "Ratio of PV oriented towards north";
	  parameter Real A_e = 0.1 "Ratio of PV oriented towards east";
	  parameter Real A_w = 0.0 "Ratio of PV oriented towards west";
	  parameter Modelica.SIunits.Power P_solar = 600000 "Nominal power for PV panels";
      parameter Real A_pv = P_solar/(effPV*Qrad) "Area with PV panels";
	  parameter Real effPV = 0.2 "Efficiency of PV panels";
	  parameter Modelica.SIunits.Power Qrad = 1000 "Maximum solar radiation per square meter";
	equation
	  
	  // Determine the power of the PVs
	  pv.P = (u[4]*A_e + u[5]*A_n + u[6]*A_s + u[7]*A_w)*A_pv*effPV;
	  pv.Q = 0.0;
	  
	  // Connect PV to the electric terminal of the building
	  connect(p, pv.p);
	  	
	end BaseBuildingPV;

	model RCBuildingModel2
	  "RC model of a LBNL building 71 (Reduced Order Model - 2 state variables - RC type)"
	  extends ElectricNetwork.BaseBuilding(
	    N = 2, M = 7, O = 1, Tstart = 273.15+20, A_tot = 5016.76416,
	    A = [-1.13701970e-05, 5.64289098e-06; 5.64289098e-07, -3.08438960e-06],
	    B = [1.15740741e-05, 5.72730601e-06, 0.00000000e+00, 7.45634055e-09, 6.94015527e-08, 6.92836104e-08, 8.12800210e-09;
	         0.00000000e+00, 0.00000000e+00, 2.52010050e-06, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00],
	    C = [1.0, 0.0]);
	end RCBuildingModel2;
	
	model RCBuildingModel2PV
	  "RC model of a LBNL building 71 (Reduced Order Model - 2 state variables - RC type)"
	  extends ElectricNetwork.BaseBuildingPV(
	    N = 2, M = 7, O = 1, Tstart = 273.15+20, A_tot = 5016.76416,
	    A = [-1.13701970e-05, 5.64289098e-06; 5.64289098e-07, -3.08438960e-06],
	    B = [1.15740741e-05, 5.72730601e-06, 0.00000000e+00, 7.45634055e-09, 6.94015527e-08, 6.92836104e-08, 8.12800210e-09;
	         0.00000000e+00, 0.00000000e+00, 2.52010050e-06, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00, 0.00000000e+00],
	    C = [1.0, 0.0]);
	end RCBuildingModel2PV;

	model RCBuildingModel8
	  "RC model of a LBNL building 71 (Reduced Order Model - 8 state variables, only Tmix)"
	  extends ElectricNetwork.BaseBuilding(
	    N = 8, M = 7, O = 1, Tstart = 273.15+20, A_tot = 5016.76416,
	    A = [-0.0000076807, 0.0000264670, 0.0000401905, 0.0000425972, -0.0000368926, -0.0000100447, -0.0000106466, 0.0000032205; 0.0000248593, -0.0001468261, -0.0003049261, -0.0003460303, 0.0003125732, 0.0000886882, 0.0000966372, -0.0000293426; 0.0000292291, -0.0002127179, -0.0006396612, -0.0008354038, 0.0008968544, 0.0002766462, 0.0003118949, -0.0000953804; 0.0000285837, -0.0002361816, -0.0008107120, -0.0011412932, 0.0014112943, 0.0004617233, 0.0005343701, -0.0001645938; -0.0000333183, 0.0002859769, 0.0008331868, 0.0011686773, -0.0018071978, -0.0007494284, -0.0009560175, 0.0003010742; -0.0000086662, 0.0000857313, 0.0002330402, 0.0003373681, -0.0005564615, -0.0003281745, -0.0005979924, 0.0001989155; -0.0000090705, 0.0000893977, 0.0003082747, 0.0005141603, -0.0009375785, -0.0005308093, -0.0020813258, 0.0009388022; 0.0000026413, -0.0000248367, -0.0000924425, -0.0001590406, 0.0002953111, 0.0001539649, 0.0008752038, -0.0005212585],
	    B = [-0.0023765430, -0.0009694831, -0.0012510260, -0.0000014213, -0.0000126499, -0.0000126499, -0.0000014213; 0.0054578740, 0.0004575349, 0.0024000689, 0.0000008343, 0.0000077609, 0.0000077609, 0.0000008343; 0.0079289763, -0.0002539306, -0.0008655943, -0.0000013476, -0.0000114039, -0.0000114039, -0.0000013476; 0.0079910917, -0.0002040695, -0.0018887522, -0.0000014388, -0.0000136813, -0.0000136813, -0.0000014388; -0.0068615127, -0.0014075129, -0.0004114607, -0.0000022905, -0.0000196376, -0.0000196376, -0.0000022905; -0.0017181585, 0.0003183989, -0.0007029392, 0.0000004319, 0.0000009974, 0.0000009974, 0.0000004319; -0.0019805508, -0.0000413197, -0.0000620118, 0.0000011606, 0.0000085077, 0.0000085077, 0.0000011606; 0.0005799727, 0.0001270611, -0.0000788008, 0.0000007811, 0.0000028771, 0.0000028771, 0.0000007811],
	    C = [-0.0028553887, 0.0059798144, 0.0079801418, 0.0082138270, -0.0070165184, -0.0018835001, -0.0019819894, 0.0005989492],
	    linBuiModel(x_start={-122607,3639.71,-17432.3,5786.65,-1898.14, -402.35,806.319,720.688}));
	end RCBuildingModel8;
	
	model RCBuildingModel8PV
	  "RC model of a LBNL building 71 (Reduced Order Model - 8 state variables, only Tmix)"
	  extends ElectricNetwork.BaseBuildingPV(
	    N = 8, M = 7, O = 1, Tstart = 273.15+20, A_tot = 5016.76416,
	    A = [-0.0000076807, 0.0000264670, 0.0000401905, 0.0000425972, -0.0000368926, -0.0000100447, -0.0000106466, 0.0000032205; 0.0000248593, -0.0001468261, -0.0003049261, -0.0003460303, 0.0003125732, 0.0000886882, 0.0000966372, -0.0000293426; 0.0000292291, -0.0002127179, -0.0006396612, -0.0008354038, 0.0008968544, 0.0002766462, 0.0003118949, -0.0000953804; 0.0000285837, -0.0002361816, -0.0008107120, -0.0011412932, 0.0014112943, 0.0004617233, 0.0005343701, -0.0001645938; -0.0000333183, 0.0002859769, 0.0008331868, 0.0011686773, -0.0018071978, -0.0007494284, -0.0009560175, 0.0003010742; -0.0000086662, 0.0000857313, 0.0002330402, 0.0003373681, -0.0005564615, -0.0003281745, -0.0005979924, 0.0001989155; -0.0000090705, 0.0000893977, 0.0003082747, 0.0005141603, -0.0009375785, -0.0005308093, -0.0020813258, 0.0009388022; 0.0000026413, -0.0000248367, -0.0000924425, -0.0001590406, 0.0002953111, 0.0001539649, 0.0008752038, -0.0005212585],
	    B = [-0.0023765430, -0.0009694831, -0.0012510260, -0.0000014213, -0.0000126499, -0.0000126499, -0.0000014213; 0.0054578740, 0.0004575349, 0.0024000689, 0.0000008343, 0.0000077609, 0.0000077609, 0.0000008343; 0.0079289763, -0.0002539306, -0.0008655943, -0.0000013476, -0.0000114039, -0.0000114039, -0.0000013476; 0.0079910917, -0.0002040695, -0.0018887522, -0.0000014388, -0.0000136813, -0.0000136813, -0.0000014388; -0.0068615127, -0.0014075129, -0.0004114607, -0.0000022905, -0.0000196376, -0.0000196376, -0.0000022905; -0.0017181585, 0.0003183989, -0.0007029392, 0.0000004319, 0.0000009974, 0.0000009974, 0.0000004319; -0.0019805508, -0.0000413197, -0.0000620118, 0.0000011606, 0.0000085077, 0.0000085077, 0.0000011606; 0.0005799727, 0.0001270611, -0.0000788008, 0.0000007811, 0.0000028771, 0.0000028771, 0.0000007811],
	    C = [-0.0028553887, 0.0059798144, 0.0079801418, 0.0082138270, -0.0070165184, -0.0018835001, -0.0019819894, 0.0005989492],
	    linBuiModel(x_start={-122607,3639.71,-17432.3,5786.65,-1898.14, -402.35,806.319,720.688}));
	end RCBuildingModel8PV;
	
	model SingleBuildingElectric
		extends ElectricNetwork.RCBuildingModel8;
        ElectricNetwork.Source S(Vrms=Vs);
        Real S_pow;
        Real P_pow;
    equation
    	// No control
    	Pctrl = 0.0;
    	
    	// Connect source grid to the building
    	connect(S.p, p);
    	
    	// Compute energy and cost using voltage and currents
    	S_pow = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2]);
    	P_pow = -(bldg.P + batt.P);
    	
	    der(Money) = P_pow*price/1000.0/3600.0;
	    der(E) = ElectricNetwork.smooth_max(0.0, P_pow)/1000.0/3600.0;
	    
	end SingleBuildingElectric;
	
	model SingleBuildingElectricCtrl
		extends ElectricNetwork.RCBuildingModel8;
        ElectricNetwork.Source S(Vrms=Vs);
        Real S_pow;
        Real P_pow;
        ElectricNetwork.smooth_lim_PI pi_up(K = 2*6e3, Ti = 1e5, CS_max = 0, CS_min=-2.5e5, b = 1.0, CS_start = -2e5);
    equation
    
    	// Connect source grid to the building
    	connect(S.p, p);
    	
    	// Compute energy and cost using voltage and currents
    	S_pow = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2]);
    	P_pow = -(bldg.P + batt.P);
    	
	    der(Money) = P_pow*price/1000.0/3600.0;
	    der(E) = ElectricNetwork.smooth_max(0.0, P_pow)/1000.0/3600.0;
	    
	    // Control the building Temperature with PI
        Pctrl = pi_up.cs;
        pi_up.sp = 273.15 + 23;
        pi_up.pv = Tmix;	
	    
	end SingleBuildingElectricCtrl;
	
	model SingleBuildingElectricCtrlRelay
		extends ElectricNetwork.RCBuildingModel8;
        ElectricNetwork.Source S(Vrms=Vs);
        Real S_pow;
        Real P_pow;
        Real CoolPower = -2.1e5;
        discrete Boolean cooling;
    initial equation
    	pre(cooling) = false;
    algorithm
    	// Control the building Temperature
	    when Tmix >= 273.15 + 23.9 and pre(cooling) == false then
	    	cooling := true;
	    end when;
	    
	    when Tmix <= 273.15 + 20.1 and pre(cooling) == true then
	    	cooling := false;
	    end when;
    equation
    
    	// Connect source grid to the building
    	connect(S.p, p);
    	
    	// Compute energy and cost using voltage and currents
    	S_pow = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2]);
    	P_pow = -(bldg.P + batt.P);
    	
	    der(Money) = P_pow*price/1000.0/3600.0;
	    der(E) = ElectricNetwork.smooth_max(0.0, P_pow)/1000.0/3600.0;
	    
        Pctrl + 360*der(Pctrl) = if (cooling) then CoolPower else 0.4*CoolPower;
	    
	end SingleBuildingElectricCtrlRelay;
	
	model SingleBuildingElectricCtrlRelayPV
		extends ElectricNetwork.RCBuildingModel8PV;
        ElectricNetwork.Source S(Vrms=Vs);
        Real S_pow;
        Real P_pow;
        Real CoolPower = -2.1e5;
        discrete Boolean cooling;
    initial equation
    	pre(cooling) = false;
    algorithm
    	// Control the building Temperature
	    when Tmix >= 273.15 + 23.9 and pre(cooling) == false then
	    	cooling := true;
	    end when;
	    
	    when Tmix <= 273.15 + 20.1 and pre(cooling) == true then
	    	cooling := false;
	    end when;
    equation
    
    	// Connect source grid to the building
    	connect(S.p, p);
    	
    	// Compute energy and cost using voltage and currents
    	S_pow = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2]);
    	P_pow = -(pv.P + bldg.P + batt.P);
    	
	    der(Money) = P_pow*price/1000.0/3600.0;
	    der(E) = ElectricNetwork.smooth_max(0.0, P_pow)/1000.0/3600.0;
	    
        Pctrl + 360*der(Pctrl) = if (cooling) then CoolPower else 0.4*CoolPower;
	    
	end SingleBuildingElectricCtrlRelayPV;
	
	model SingleBuildingElectricCtrlPV
		extends ElectricNetwork.RCBuildingModel8PV;
        ElectricNetwork.Source S(Vrms=Vs);
        Real S_pow;
        Real P_pow;
        ElectricNetwork.smooth_lim_PI pi_up(K = 1e3, Ti = 1.0e3, CS_max = 0, CS_min=-2.5e5, b = 1.0);
    equation
    
    	// Connect source grid to the building
    	connect(S.p, p);
    	
    	// Compute energy and cost using voltage and currents
    	S_pow = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2]);
    	P_pow = -(pv.P + bldg.P + batt.P);
    	
	    der(Money) = P_pow*price/1000.0/3600.0;
	    der(E) = ElectricNetwork.smooth_max(0.0, P_pow)/1000.0/3600.0;
	    
	    // Control the building Temperature with PI
        Pctrl = pi_up.cs;
        pi_up.sp = 273.15 + 23;
        pi_up.pv = Tmix;	
	    
	end SingleBuildingElectricCtrlPV;
	
	model SingleBuildingElectricPV
		extends ElectricNetwork.RCBuildingModel8PV;
        ElectricNetwork.Source S(Vrms=Vs);
        Real S_pow;
        Real P_pow;
    equation
    	// No control
    	Pctrl = 0.0;
    
    	// Connect source grid to the building
    	connect(S.p, p);
    	
    	// Compute energy and cost using voltage and currents
    	S_pow = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2]);
    	P_pow = -(pv.P + bldg.P + batt.P);
    	
	    der(Money) = P_pow*price/1000.0/3600.0;
	    der(E) = ElectricNetwork.smooth_max(0.0, P_pow)/1000.0/3600.0;
	    
	end SingleBuildingElectricPV;
	
	optimization BuildingMngmtOpt_E( objective = E(finalTime),
								     objectiveIntegrand = 0*1e-12*P_hvac*P_hvac,
									 startTime = 0.0, finalTime = 24.0*3600.0*6.0 )
        extends ElectricNetwork.SingleBuildingElectric(
        E(free = true, initialGuess = 0.0, min = 0.0),
        Money(free = false, initialGuess = 0.0, min = 0.0),
        SOCstart(free = false, initialGuess=0.5, min=0.2, max=1.0));
        parameter Real Tmin = 273.15+20;
        parameter Real Tmax = 273.15+24;
        parameter Real Pmax_charge = 0.5e5;
    constraint
        Money(startTime) = 0.0;
        Tmix <= Tmax;
        Tmin <= Tmix;
        P_hvac <= 0;
        -2.5e5 <= P_hvac;
        batt.SOC <= 1.0;
        0.2 <= batt.SOC;
        batt.P <= Pmax_charge;
        -Pmax_charge <= batt.P;
        
        batt.SOC(finalTime) = batt.SOC(startTime);
        
    end BuildingMngmtOpt_E;
    
    optimization BuildingMngmtOpt_E_PV( objective = E(finalTime),
    									objectiveIntegrand = 0*0.1e-12*P_hvac*P_hvac,
    									startTime = 0.0, finalTime = 24.0*3600.0*6.0 )
        extends ElectricNetwork.SingleBuildingElectricPV(
        E(free = true, initialGuess = 0.0, min = 0.0),
        Money(free = false, initialGuess = 0.0, min = 0.0),
        SOCstart(free = true, initialGuess=0.5, min=0.2, max=1.0));
        parameter Real Tmin = 273.15+20;
        parameter Real Tmax = 273.15+24;
        parameter Real Pmax_charge = 0.5e5;
    constraint
        Money(startTime) = 0.0;
        Tmix <= Tmax;
        Tmin <= Tmix;
        P_hvac <= 0;
        -2.5e5 <= P_hvac;
        batt.SOC <= 1.0;
        0.2 <= batt.SOC;
        batt.P <= Pmax_charge;
        -Pmax_charge <= batt.P;
        
        batt.SOC(finalTime) = batt.SOC(startTime);
        
    end BuildingMngmtOpt_E_PV;

	optimization BuildingMngmtOpt_E_PV_batt_constraints
		extends BuildingMngmtOpt_E_PV;
	constraint
		
		batt.SOC(24.0*3600.0*1.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*1.0);
        
        batt.SOC(24.0*3600.0*2.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*2.0);
        
        batt.SOC(24.0*3600.0*3.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*3.0);
        
        batt.SOC(24.0*3600.0*4.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*4.0);
        
        batt.SOC(24.0*3600.0*5.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*5.0);
        
	end BuildingMngmtOpt_E_PV_batt_constraints;

    optimization BuildingMngmtOpt_Money( objective = Money(finalTime), 
    									 objectiveIntegrand = 0*1e-14*P_hvac*P_hvac,
    									 startTime = 0.0, finalTime = 24.0*3600.0*6.0 )
        extends ElectricNetwork.SingleBuildingElectric(
        E(free=true, initialGuess = 0.0, min = 0.0),
        Money(free=true, initialGuess = 0.0, min = 0.0),
        SOCstart(free = true, initialGuess=0.5, min=0.2, max=1.0));
        parameter Real Tmin = 273.15+20;
        parameter Real Tmax = 273.15+24;
        parameter Real Pmax_charge = 0.5e5;
    constraint
        Money(startTime) = 0.0;
        Tmix <= Tmax;
        Tmin <= Tmix;
        P_hvac <= 0;
        -2.5e5 <= P_hvac;
        batt.SOC <= 1.0;
        0.2 <= batt.SOC;
        batt.P <= Pmax_charge;
        -Pmax_charge <= batt.P;
        
        batt.SOC(finalTime) = batt.SOC(startTime);
        
    end BuildingMngmtOpt_Money;
    
    /* change cost of energy to be only the one consumed not produced */
    optimization BuildingMngmtOpt_Money_PV( objective = Money(finalTime), 
    									    objectiveIntegrand = 0*1e-14*P_hvac*P_hvac,
    										startTime = 0.0, finalTime = 24.0*3600.0*6.0 )
        extends ElectricNetwork.SingleBuildingElectricPV(
        E(free=true, initialGuess = 0.0, min = 0.0),
        Money(free=true, initialGuess = 0.0, min = 0.0),
        SOCstart(free = true, initialGuess=0.5, min=0.2, max=1.0));
        parameter Real Tmin = 273.15+20;
        parameter Real Tmax = 273.15+24;
        parameter Real Pmax_charge = 0.5e5;
    constraint
        Money(startTime) = 0.0;
        Tmix <= Tmax;
        Tmin <= Tmix;
        P_hvac <= 0;
        -2.5e5 <= P_hvac;
        batt.SOC <= 1.0;
        0.2 <= batt.SOC;
        batt.P <= Pmax_charge;
        -Pmax_charge <= batt.P;
        batt.SOC(finalTime) = batt.SOC(startTime);
        
    end BuildingMngmtOpt_Money_PV;

	optimization BuildingMngmtOpt_Money_PV_batt_constraints
		extends BuildingMngmtOpt_Money_PV;
	constraint
	
		batt.SOC(24.0*3600.0*1.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*1.0);
        
        batt.SOC(24.0*3600.0*2.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*2.0);
        
        batt.SOC(24.0*3600.0*3.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*3.0);
        
        batt.SOC(24.0*3600.0*4.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*4.0);
        
        batt.SOC(24.0*3600.0*5.0) <= 1.1*batt.SOC(startTime);
        0.9*batt.SOC(startTime) <= batt.SOC(24.0*3600.0*5.0);
        
	end BuildingMngmtOpt_Money_PV_batt_constraints;
	
	model BuildingElectricPV
		extends ElectricNetwork.RCBuildingModel8PV(p(v(start = {Vn, 0})));
		parameter Modelica.SIunits.Voltage Vn = 4800;
		Modelica.SIunits.Voltage Vrms(start = Vn);
        Real S_pow;
        Real P_pow;
    equation
    	// No control
    	Pctrl = 0.0;
    
    	// Voltage at node
    	Vrms = sqrt(p.v[1]*p.v[1] + p.v[2]*p.v[2]);
    	
    	// Compute energy and cost using voltage and currents
    	S_pow = -(p.v[1]*p.i[1] + p.v[2]*p.i[2]);
    	P_pow = -(pv.P + bldg.P + batt.P);
    	
	    der(Money) = P_pow*price/1000.0/3600.0;
	    der(E) = ElectricNetwork.smooth_max(0.0, P_pow)/1000.0/3600.0;
	    
	end BuildingElectricPV;
	
	model District
		"Model of a district system, buildings + electrical network"
		// Parameters
        parameter Real Tsp_bui = 273.15 + 22;
	    parameter Real R1 = 1.5*1.2 "Line resistance 1";
        parameter Real R2 = 1.5*1.1 "Line resistance 2";
        parameter Real R3 = 1.5*1.05 "Line resistance 3";
        parameter Modelica.SIunits.Voltage Vs = 4800 "Voltage source";
 	
	  	// Variables
	  	Real E(start = 0.0, fixed = true) "Electric energy consumed by the district";
	  	Real Money(start = 0.0, fixed = true) "Money to run the district"; 
	  	
	  	// Inputs & outputs
	    Modelica.Blocks.Interfaces.RealInput price "Price of kWh"; 
	  	Modelica.Blocks.Interfaces.RealInput ihg_1 "Internal heat gains for building 1";
	  	Modelica.Blocks.Interfaces.RealInput ihg_2 "Internal heat gains for building 2";
	  	Modelica.Blocks.Interfaces.RealInput ihg_3 "Internal heat gains for building 3";
	    Modelica.Blocks.Interfaces.RealInput Tamb;
	    Modelica.Blocks.Interfaces.RealInput Tgnd;
	    Modelica.Blocks.Interfaces.RealInput solGlobFac_E;
	    Modelica.Blocks.Interfaces.RealInput solGlobFac_N;
	    Modelica.Blocks.Interfaces.RealInput solGlobFac_S;
	    Modelica.Blocks.Interfaces.RealInput solGlobFac_W;
	    Modelica.Blocks.Interfaces.RealInput P_hvac_A;
	    Modelica.Blocks.Interfaces.RealInput P_hvac_B;
	    Modelica.Blocks.Interfaces.RealInput P_hvac_C;
	    Modelica.Blocks.Interfaces.RealInput P_batt_A;
	    Modelica.Blocks.Interfaces.RealInput P_batt_B;
	    Modelica.Blocks.Interfaces.RealInput P_batt_C;
	
	  	// Models
	  	ElectricNetwork.BuildingElectricPV buiA(Vn = Vs, A_s = 0.9, A_n = 0.0, A_e = 0.1, A_w = 0.0, P_solar = 6.0e5) "Building A";
		ElectricNetwork.BuildingElectricPV buiB(Vn = Vs, A_s = 0.7, A_n = 0.0, A_e = 0.15, A_w = 0.15, P_solar = 5.5e5) "Building B";
		ElectricNetwork.BuildingElectricPV buiC(Vn = Vs, A_s = 0.7, A_n = 0.0, A_e = 0.3, A_w = 0.0, P_solar = 4.5e5) "Building C";
	    
		ElectricNetwork.Source S(Vrms=Vs);
		
		ElectricNetwork.Line line1(R=R1, X=R1/10);
		ElectricNetwork.Line line2(R=R2, X=R2/12);
		ElectricNetwork.Line line3(R=R3, X=R3/10);
			
	equation
	
		// Energy and money to run the district
		der(Money) = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2])*price/1000.0/3600.0;
		der(E) = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2])/1000.0/3600.0;
		
	    // Connect the lines to the source
		connect(S.p,     line1.a);
		connect(line1.b, line2.a);
		connect(line2.b, line3.a);
		
		// Connect each building and PVs
		connect(buiA.p, line1.b);
		connect(buiB.p, line2.b);
		connect(buiC.p, line3.b);
		
		// Connect the external weather inputs to the buildings
		buiA.price = price;      buiB.price = price;      buiC.price = price;
		buiA.u[1] = ihg_1;       buiB.u[1] = ihg_2;       buiC.u[1] = ihg_3;
		buiA.u[2] = Tamb;        buiB.u[2] = Tamb;        buiC.u[2] = Tamb;
		buiA.u[3] = Tgnd;        buiB.u[3] = Tgnd;        buiC.u[3] = Tgnd;
		buiA.u[4] = solGlobFac_E;buiB.u[4] = solGlobFac_E;buiC.u[4] = solGlobFac_E;
		buiA.u[5] = solGlobFac_N;buiB.u[5] = solGlobFac_N;buiC.u[5] = solGlobFac_N;
		buiA.u[6] = solGlobFac_S;buiB.u[6] = solGlobFac_S;buiC.u[6] = solGlobFac_S;
		buiA.u[7] = solGlobFac_W;buiB.u[7] = solGlobFac_W;buiC.u[7] = solGlobFac_W;
		
		connect(buiA.P_hvac, P_hvac_A);
		connect(buiB.P_hvac, P_hvac_B);
		connect(buiC.P_hvac, P_hvac_C);
		
		connect(buiA.P_batt, P_batt_A);
		connect(buiB.P_batt, P_batt_B);
		connect(buiC.P_batt, P_batt_C);
		
	end District;

	optimization OptimizationDistrict_E( objective = E(finalTime), startTime = 0.0, finalTime = 24.0*3600.0 )
		extends ElectricNetwork.District(
		E(free=true, initialGuess = 0.0, min = 0.0),
		Money(free=false, initialGuess = 0.0, min = 0.0),
		buiA(SOCstart(free = true, initialGuess = 0.5, min = 0.2, max = 1.0)),
		buiB(SOCstart(free = true, initialGuess = 0.5, min = 0.2, max = 1.0)),
		buiC(SOCstart(free = true, initialGuess = 0.5, min = 0.2, max = 1.0)));
		parameter Real tol = 0.05;
		parameter Real Pmax_charge = 1e5;
		parameter Real Tmin = 273.15+20;
        parameter Real Tmax = 273.15+24;
	constraint
		Money(startTime)=0.0;

		buiA.P_hvac <= 0;
        -2.5e5 <= buiA.P_hvac;
        
        buiB.P_hvac <= 0;
        -2.5e5 <= buiB.P_hvac;
        
        buiC.P_hvac <= 0;
        -2.5e5 <= buiC.P_hvac;

		buiA.batt.SOC <= 1.0;
		0.2 <= buiA.batt.SOC;
		
		buiB.batt.SOC <= 1.0;
		0.2 <= buiB.batt.SOC;
		
		buiC.batt.SOC <= 1.0;
		0.2 <= buiC.batt.SOC;
		
		buiA.batt.P <= Pmax_charge;
		-Pmax_charge <= buiA.batt.P;
		
		buiB.batt.P <= Pmax_charge;
		-Pmax_charge <= buiB.batt.P;
		
		buiC.batt.P <= Pmax_charge;
		-Pmax_charge <= buiC.batt.P;
		
		buiA.batt.SOC(finalTime) = buiA.batt.SOC(startTime);
		buiB.batt.SOC(finalTime) = buiB.batt.SOC(startTime);
		buiC.batt.SOC(finalTime) = buiC.batt.SOC(startTime);
		
		buiA.Vrms <= buiA.Vn*1.02;
		buiB.Vrms <= buiA.Vn*1.02;
		buiC.Vrms <= buiA.Vn*1.02;
		buiA.Vn*0.95 <= buiA.Vrms;
		buiA.Vn*0.95 <= buiB.Vrms;
		buiA.Vn*0.95 <= buiC.Vrms;
		
		buiA.Tmix <= Tmax;
		buiB.Tmix <= Tmax;
		buiC.Tmix <= Tmax;   
		
		Tmin <= buiA.Tmix;
		Tmin <= buiB.Tmix;
		Tmin <= buiC.Tmix;
		
	end OptimizationDistrict_E;
	
	optimization OptimizationDistrict_Money( objective = Money(finalTime), startTime = 0.0, finalTime = 24.0*3600.0*6 )
		extends ElectricNetwork.District(
		E(free=true, initialGuess = 0.0, min = 0.0),
		Money(free=false, initialGuess = 0.0, min = 0.0),
		buiA(SOCstart(free = true, initialGuess = 0.5, min = 0.2, max = 1.0)),
		buiB(SOCstart(free = true, initialGuess = 0.5, min = 0.2, max = 1.0)),
		buiC(SOCstart(free = true, initialGuess = 0.5, min = 0.2, max = 1.0)));
		parameter Real tol = 0.05;
		parameter Real Pmax_charge = 1e5;
		parameter Real Tmin = 273.15+20;
        parameter Real Tmax = 273.15+24;
	constraint
		Money(startTime)=0.0;

		buiA.P_hvac <= 0;
        -2.5e5 <= buiA.P_hvac;
        
        buiB.P_hvac <= 0;
        -2.5e5 <= buiB.P_hvac;
        
        buiC.P_hvac <= 0;
        -2.5e5 <= buiC.P_hvac;

		buiA.batt.SOC <= 1.0;
		0.2 <= buiA.batt.SOC;
		
		buiB.batt.SOC <= 1.0;
		0.2 <= buiB.batt.SOC;
		
		buiC.batt.SOC <= 1.0;
		0.2 <= buiC.batt.SOC;
		
		buiA.batt.P <= Pmax_charge;
		-Pmax_charge <= buiA.batt.P;
		
		buiB.batt.P <= Pmax_charge;
		-Pmax_charge <= buiB.batt.P;
		
		buiC.batt.P <= Pmax_charge;
		-Pmax_charge <= buiC.batt.P;
		
		buiA.batt.SOC(finalTime) = buiA.batt.SOC(startTime);
		buiB.batt.SOC(finalTime) = buiB.batt.SOC(startTime);
		buiC.batt.SOC(finalTime) = buiC.batt.SOC(startTime);
		
		buiA.Vrms <= buiA.Vn*1.02;
		buiB.Vrms <= buiA.Vn*1.02;
		buiC.Vrms <= buiA.Vn*1.02;
		//buiA.Vn*0.95 <= buiA.Vrms;
		//buiA.Vn*0.95 <= buiB.Vrms;
		//buiA.Vn*0.95 <= buiC.Vrms;
		
		buiA.Tmix <= Tmax;
		buiB.Tmix <= Tmax;
		buiC.Tmix <= Tmax;   
		
		Tmin <= buiA.Tmix;
		Tmin <= buiB.Tmix;
		Tmin <= buiC.Tmix;
		
	end OptimizationDistrict_Money;
	
	model ACnetworkSimple
		ElectricNetwork.Source S(Vrms=220);
		ElectricNetwork.Load L;
		ElectricNetwork.Line line1(R=0.1, X=0.1);
		Modelica.Blocks.Interfaces.RealInput P;
		Modelica.Blocks.Interfaces.RealInput Q;
	equation
		connect(S.p, line1.a);
		connect(line1.b, L.p);
		L.P = P;
		L.Q = Q;
	end ACnetworkSimple;
	
	model ACnetwork
		parameter Real SOCstart = 0.5;
		parameter Real R1 = 1.8*1.2 "Line resistance 1";
        parameter Real R2 = 1.8*1.1 "Line resistance 2";
        parameter Real R3 = 1.8*1.05 "Line resistance 3";
        parameter Real ratio1 = 1 "power ratio PV panels 1";
        parameter Real ratio2 = 1 "power PV panels 2";
        parameter Real ratio3 = 1 "power PV panels 3";
        parameter Real A1 = P1*ratio1/(effPV*Qrad) "Area with PV panels 1";
        parameter Real A2 = P2*ratio2/(effPV*Qrad) "Area with PV panels 2";
        parameter Real A3 = P3*ratio3/(effPV*Qrad) "Area with PV panels 3";
        parameter Modelica.SIunits.Power P1 = 220000 "Nominal power consumption building 1";
        parameter Modelica.SIunits.Power P2 = 175000 "Nominal power consumption building 2";
        parameter Modelica.SIunits.Power P3 = 190000 "Nominal power consumption building 3";
        parameter Modelica.SIunits.Energy Ebatt = 1.0*(P1+P2+P3)*2*3600 "Storage capacity for the battery";
        parameter Modelica.SIunits.Voltage Vs = 4800 "Voltage source";
	    parameter Real effPV = 0.9*0.12 "Efficiency of PV panels";
	  	parameter Modelica.SIunits.Power Qrad = 800 "Maximum solar radiation per square meter";
	  	
	    /// Variable of the model
	    Real Balance;
	    Real Ebal(start = 0.0, fixed = true);
        Real Money(start = 0.0, fixed = true);
		Modelica.SIunits.Energy E(start=0.0, fixed = true) "Energy consumption of the network";
		
		ElectricNetwork.Source S(Vrms=Vs);
		
		ElectricNetwork.Load bldg1(Vn=Vs);
		ElectricNetwork.Load bldg2(Vn=Vs);
		ElectricNetwork.Load bldg3(Vn=Vs);
		
		ElectricNetwork.Load pv1(Vn=Vs);
		ElectricNetwork.Load pv2(Vn=Vs);
		ElectricNetwork.Load pv3(Vn=Vs);
		
		ElectricNetwork.Battery batt(Vn=Vs, SOCstart = SOCstart, Ebatt = Ebatt);
		
		ElectricNetwork.Line line1(R=R1, X=R1/10);
		ElectricNetwork.Line line2(R=R2, X=R2/12);
		ElectricNetwork.Line line3(R=R3, X=R3/10);
		
		Modelica.Blocks.Interfaces.RealInput P_bldg1;
		Modelica.Blocks.Interfaces.RealInput P_bldg2;
		Modelica.Blocks.Interfaces.RealInput P_bldg3;
		Modelica.Blocks.Interfaces.RealInput P_pv1;
		Modelica.Blocks.Interfaces.RealInput P_pv2;
		Modelica.Blocks.Interfaces.RealInput P_pv3;
		
		Modelica.Blocks.Interfaces.RealInput P_batt;
		Modelica.Blocks.Interfaces.RealInput Q_batt;
		
		Modelica.Blocks.Interfaces.RealInput price;
		
		//Real action(start = 0, fixed=true, initialGuess=0);
        //Real cost(initialGuess=0);
        //ElectricNetwork.Derivative D(T = 10, k=0.0001);
        //ElectricNetwork.FirstOrder fo(T = 5, k=1);
	equation
		Balance = P_bldg2*P2 + P_bldg1*P1 + P_bldg3*P3 + P_pv1*Qrad*A1*effPV + P_pv2*Qrad*A2*effPV + P_pv3*Qrad*A3*effPV;
		der(Ebal) = Balance;
		
		// Derivative of the control action
	    // D.u = batt.P;
	    // fo.u = D.y*atan(5*D.y)/(Modelica.Constants.pi/2.0);
	    // Integrate the derivative of the control in order to avoid big variations
        // der(action) = batt.P^2;
        // The cost is a mix of money and action
        //cost = Money;
	
		//Money = E*price;
		der(Money) = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2])/1000.0*price/3600.0;
		1000*3600*der(E) = -(S.p.v[1]*S.p.i[1] + S.p.v[2]*S.p.i[2]);
		
		connect(S.p,     line1.a);
		connect(line1.b, line2.a);
		connect(line2.b, line3.a);
		connect(line3.b, batt.p);
		
		connect(bldg1.p, line1.b);
		connect(pv1.p, line1.b);
		connect(bldg2.p, line2.b);
		connect(pv2.p, line2.b);
		connect(bldg3.p, line3.b);
		connect(pv3.p, line3.b);
		
		bldg1.P = P_bldg1*P1;
		bldg1.Q = P_bldg1/8.0;
		
		bldg2.P = P_bldg2*P2;
		bldg2.Q = P_bldg2/9.0;
		
		bldg3.P = P_bldg3*P3;
		bldg3.Q = P_bldg3/10.0;
		
		pv1.P = P_pv1*Qrad*A1*effPV;
		pv1.Q = 0;
		pv2.P = P_pv2*Qrad*A2*effPV;
		pv2.Q = 0;
		pv3.P = P_pv3*Qrad*A3*effPV;
		pv3.Q = 0;
		
		batt.P = P_batt;
		batt.Q = Q_batt;
		
	end ACnetwork;
	
    model Network "Flattened model of an electrical DC network"
	  /// Parameters for the model
      parameter Real R1 = 1.2 "Line resistance 1";
      parameter Real R2 = 1.1 "Line resistance 2";
      parameter Real R3 = 1.05 "Line resistance 3";
      parameter Real A1 = 1400 "Area with PV panels 1";
      parameter Real A2 = 900 "Area with PV panels 2";
      parameter Real A3 = 1200 "Area with PV panels 3";
      parameter Modelica.SIunits.Power P1 = 200000 "Nominal power consumption building 1";
      parameter Modelica.SIunits.Power P2 = 175000 "Nominal power consumption building 2";
      parameter Modelica.SIunits.Power P3 = 180000 "Nominal power consumption building 3";
      parameter Modelica.SIunits.Energy Ebatt = 0.2*(P1+P2+P3)*2*3600 "Storage capacity for the battery";
      parameter Modelica.SIunits.Voltage Vs = 4800 "Voltage source";
	  parameter Real effPV = 0.9*0.12 "Efficiency of PV panels";
	  
	  /// Variable of the model
      parameter Modelica.SIunits.Power Qrad = 800 "Maximum solar radiation per square meter";
      Modelica.SIunits.Energy E(start=0.0, fixed = true) "Energy consumption of the network";
      Modelica.SIunits.Voltage V1(start = Vs, nominal=Vs) "Voltage at the node";
      Modelica.SIunits.Voltage V2(start = Vs, nominal=Vs) "Voltage at the node";
      Modelica.SIunits.Voltage V3(start = Vs, nominal=Vs) "Voltage at the node";
      Modelica.SIunits.Current Is,I2,I3,IL_1,IL_2,IL_3,IS_1,IS_2,IS_3 "Currents in branches and nodes";
	  /// State variables
      Real SOC(start = SOCstart, fixed = true, min = 0, max = 1);
	  Real Money(start = 0.0, fixed = true);
	  
	  /// Inputs of the model
      input Modelica.SIunits.Current Ibatt;
      input Real price;
      input Real pv1;
      input Real pv2;
      input Real pv3;
      input Real bldg1;
      input Real bldg2;
      input Real bldg3;
      parameter Real SOCstart = 0.5;
    equation
	  
	  // Energy consumed and money spent
      der(E) = Is*Vs;
      der(Money) = (Is*Vs)/1000.0*price/3600.0;
      
	  // Electrical connections
      Is = (Vs - V1)/R1;
      I2 = (V1 - V2)/R2;
      I3 = (V2 - V3)/R3;

      Is = IL_1 + IS_1 + I2;
      I2 = IL_2 + IS_2 + I3;
      I3 = IL_3 + IS_3 + Ibatt;
      
	  // Power loads
      IL_1 = bldg1*P1/V1;
      IS_1 = -Qrad*pv1*A1*effPV/V1;

      IL_2 = bldg2*P2/V2;
      IS_2 = -Qrad*pv2*A2*effPV/V2;

      IL_3 = bldg3*P3/V3;
      IS_3 = -Qrad*pv3*A3*effPV/V3;
      
	  // Ideal battery model
      Ebatt*der(SOC) = Ibatt*V3;

    end Network;

	model NetworkSim "Simple simulation model with no battery storage and fixed electricity price"
		ElectricNetwork.Network n(SOCstart = 0.8);
	equation
		n.Ibatt = 0;
		n.price = 0.1;
	end NetworkSim;
	
    optimization NetworkBatteryMngmtOpt_E( objective = E(finalTime), startTime = 0.0, finalTime = 24.0*3600.0 )
        extends ElectricNetwork.Network(SOCstart(free = true, initialGuess=0.5, min=0.1, max=1.0));
        parameter Real tol = 0.05;
    constraint
        SOC <= 1.0;
        0.1 <= SOC;
        V1 <= Vs*(1+tol);
        Vs*(1-tol) <= V1;
        V2 <= Vs*(1+tol);
        Vs*(1-tol) <= V2;
        V3 <= Vs*(1+tol);
        Vs*(1-tol) <= V3;
        SOC(finalTime) = SOC(startTime);  
    end NetworkBatteryMngmtOpt_E;
    
    optimization NetworkBatteryMngmtOpt_Money( objective = Money(finalTime), startTime = 0.0, finalTime = 24.0*3600.0 )
        extends ElectricNetwork.Network(SOCstart(free = true, initialGuess=0.5, min=0.1, max=1.0));
        parameter Real tol = 0.05;
    constraint
        SOC <= 1.0;
        0.1 <= SOC;
        V1 <= Vs*(1+tol);
        Vs*(1-tol) <= V1;
        V2 <= Vs*(1+tol);
        Vs*(1-tol) <= V2;
        V3 <= Vs*(1+tol);
        Vs*(1-tol) <= V3;
        SOC(finalTime) = SOC(startTime);
    end NetworkBatteryMngmtOpt_Money;
    
    optimization ACnetworkBatteryMngmtOpt_Money( objective = Money(finalTime), startTime = 0.0, finalTime = 24.0*3600.0 )
        extends ElectricNetwork.ACnetwork(SOCstart(free = true, initialGuess=0.5, min=0.1, max=1.0));
        parameter Real tol = 0.05;
    constraint
        batt.SOC <= 1.0;
        0.1 <= batt.SOC;
        batt.P <= 100000;
        -100000 <= batt.P;
        bldg1.Vrms <= bldg1.Vn*1.05;
        bldg2.Vrms <= bldg2.Vn*1.05;
        bldg3.Vrms <= bldg3.Vn*1.05;
        bldg1.Vn*0.95 <= bldg1.Vrms;
        bldg2.Vn*0.95 <= bldg2.Vrms;
        bldg3.Vn*0.95 <= bldg3.Vrms;
        batt.SOC(finalTime) = batt.SOC(startTime);
    end ACnetworkBatteryMngmtOpt_Money;
    
    optimization ACnetworkBatteryMngmtOpt_E( objective = E(finalTime), startTime = 0.0, finalTime = 24.0*3600.0 )
        extends ElectricNetwork.ACnetwork(SOCstart(free = true, initialGuess=0.5, min=0.1, max=1.0));
        parameter Real tol = 0.05;
    constraint
        batt.SOC <= 1.0;
        0.1 <= batt.SOC;
        batt.P <= 100000;
        -100000 <= batt.P;
        bldg1.Vrms <= bldg1.Vn*1.05;
        bldg2.Vrms <= bldg2.Vn*1.05;
        bldg3.Vrms <= bldg3.Vn*1.05;
        bldg1.Vn*0.95 <= bldg1.Vrms;
        bldg2.Vn*0.95 <= bldg2.Vrms;
        bldg3.Vn*0.95 <= bldg3.Vrms;
        batt.SOC(finalTime) = batt.SOC(startTime);
    end ACnetworkBatteryMngmtOpt_E;
	
end ElectricNetwork;
